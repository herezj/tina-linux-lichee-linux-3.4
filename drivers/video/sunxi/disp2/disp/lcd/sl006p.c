/*
 *
 * Copyright (c) 2016 Allwinnertech Co., Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 */
#include "sl006p.h"
//#include "panels.h"
/*
#include <linux/delay.h>
#include <mach/sys_config.h>
#include <linux/miscdevice.h>
#include <linux/gpio.h>
#include <linux/pinctrl/pinconf-sunxi.h>
#include <linux/pinctrl/consumer.h>*/

//extern s32 bsp_disp_get_panel_info(u32 screen_id, disp_panel_para *info);
static void LCD_power_on(u32 sel);
static void LCD_power_off(u32 sel);
static void LCD_bl_open(u32 sel);
static void LCD_bl_close(u32 sel);

static void LCD_panel_init(u32 sel);
static void LCD_panel_exit(u32 sel);

/*
static ssize_t LCD_bl_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)

{
	static char pin_name[8];
	int	config,value;
	sunxi_gpio_to_name(GPIOD(28),pin_name);
	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC,0xFFFF);
	pin_config_get(SUNXI_PINCTRL,pin_name,&config);
	if(458752 == config )
		value = 0;
	else if(131072 == config)
		value = 1;
   return sprintf(buf, "%d\n", value);

}


static ssize_t LCD_bl_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)

{
	int value;
	
	sscanf(buf, "%du", &value);
	if(value)
		LCD_bl_open(0);
	else
		LCD_bl_close(0);
	return count;

}
static struct kobj_attribute lcd_backlight_attr = __ATTR(backlight, 0666, LCD_bl_show, LCD_bl_store);


//static struct attribute lcd_backlight_attributes = lcd_backlight_attr.attr;

static struct miscdevice lcd_backlight = {	
	.minor =	MISC_DYNAMIC_MINOR,	
	.name =		"lcd-backlight",};

*/
#ifdef CONFIG_ARCH_SUN9IW1P1
__s32 dsi_dcs_rd(__u32 sel,__u8	cmd,__u8* para_p,__u32*	num_p)
{
	return 0;
}
#endif

//static u8 const mipi_dcs_pixel_format[4] = {0x77,0x66,0x66,0x55};
//#define panel_reset(val) sunxi_lcd_gpio_set_value(sel, 1, val)
//#define power_en(val)  sunxi_lcd_gpio_set_value(sel, 0, val)

static void LCD_cfg_panel_info(panel_extend_para * info)
{
	u32 i = 0, j=0;
	u32 items;
	u8 lcd_gamma_tbl[][2] =
	{
		//{input value, corrected value}
		{0, 0},
		{15, 15},
		{30, 30},
		{45, 45},
		{60, 60},
		{75, 75},
		{90, 90},
		{105, 105},
		{120, 120},
		{135, 135},
		{150, 150},
		{165, 165},
		{180, 180},
		{195, 195},
		{210, 210},
		{225, 225},
		{240, 240},
		{255, 255},
	};

	u32 lcd_cmap_tbl[2][3][4] = {
	{
		{LCD_CMAP_G0,LCD_CMAP_B1,LCD_CMAP_G2,LCD_CMAP_B3},
		{LCD_CMAP_B0,LCD_CMAP_R1,LCD_CMAP_B2,LCD_CMAP_R3},
		{LCD_CMAP_R0,LCD_CMAP_G1,LCD_CMAP_R2,LCD_CMAP_G3},
		},
		{
		{LCD_CMAP_B3,LCD_CMAP_G2,LCD_CMAP_B1,LCD_CMAP_G0},
		{LCD_CMAP_R3,LCD_CMAP_B2,LCD_CMAP_R1,LCD_CMAP_B0},
		{LCD_CMAP_G3,LCD_CMAP_R2,LCD_CMAP_G1,LCD_CMAP_R0},
		},
	};

	items = sizeof(lcd_gamma_tbl)/2;
	for(i=0; i<items-1; i++) {
		u32 num = lcd_gamma_tbl[i+1][0] - lcd_gamma_tbl[i][0];

		for(j=0; j<num; j++) {
			u32 value = 0;

			value = lcd_gamma_tbl[i][1] + ((lcd_gamma_tbl[i+1][1] - lcd_gamma_tbl[i][1]) * j)/num;
			info->lcd_gamma_tbl[lcd_gamma_tbl[i][0] + j] = (value<<16) + (value<<8) + value;
		}
	}
	info->lcd_gamma_tbl[255] = (lcd_gamma_tbl[items-1][1]<<16) + (lcd_gamma_tbl[items-1][1]<<8) + lcd_gamma_tbl[items-1][1];

	memcpy(info->lcd_cmap_tbl, lcd_cmap_tbl, sizeof(lcd_cmap_tbl));

}

static s32 LCD_open_flow(u32 sel)
{
	pr_info("[huyanhu:]LCD_open_flow---------------sl006p\n");
	LCD_OPEN_FUNC(sel, LCD_power_on, 20);   //open lcd power, and delay 50ms
	LCD_OPEN_FUNC(sel, LCD_panel_init, 10);   //open lcd power, than delay 200ms
	LCD_OPEN_FUNC(sel, sunxi_lcd_tcon_enable, 20);     //open lcd controller, and delay 100ms
	LCD_OPEN_FUNC(sel, LCD_bl_open, 0);     //open lcd backlight, and delay 0ms

	return 0;
}

static s32 LCD_close_flow(u32 sel)
{
	pr_info("[huyanhu:]LCD_close_flow---------------sl006p\n");
	LCD_CLOSE_FUNC(sel, LCD_bl_close, 0);       //close lcd backlight, and delay 0ms
	LCD_CLOSE_FUNC(sel, sunxi_lcd_tcon_disable, 0);         //close lcd controller, and delay 0ms
	LCD_CLOSE_FUNC(sel, LCD_panel_exit,	100);   //open lcd power, than delay 200ms
	LCD_CLOSE_FUNC(sel, LCD_power_off, 500);   //close lcd power, and delay 500ms

	return 0;
}

static void LCD_power_on(u32 sel)
{
	sunxi_lcd_power_enable(sel, 0);//config lcd_power pin to open lcd power0
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_power_enable(sel, 1);//config lcd_power pin to open lcd power1
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_power_enable(sel, 2);//config lcd_power pin to open lcd power2
//	sunxi_lcd_delay_ms(5);
//	sunxi_lcd_pin_cfg(sel, 1);
}

static void LCD_power_off(u32 sel)
{
	sunxi_lcd_pin_cfg(sel, 0);
	sunxi_lcd_delay_ms(10);
	sunxi_lcd_power_disable(sel, 2);//config lcd_power pin to close lcd power2
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_power_disable(sel, 1);//config lcd_power pin to close lcd power1
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_power_disable(sel, 0);//config lcd_power pin to close lcd power0
}

static void LCD_bl_open(u32 sel)
{
	sunxi_lcd_pwm_enable(sel);//open pwm module
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_backlight_enable(sel);//config lcd_bl_en pin to open lcd backlight
}

static void LCD_bl_close(u32 sel)
{
	sunxi_lcd_backlight_disable(sel);//config lcd_bl_en pin to close lcd backlight
	sunxi_lcd_delay_ms(5);
	sunxi_lcd_pwm_disable(sel);//close pwm module
}

#define REGFLAG_DELAY             				0X01
#define REGFLAG_END_OF_TABLE      				0x02   // END OF REGISTERS MARKER

struct LCM_setting_table {
    __u8 cmd;
    __u32 count;
    __u8 para_list[64];
};

#if 0
static struct LCM_setting_table otm1283_test_config_para[] = {
	{0x00, 1, 0X00},
	{0xff, 3, {0x12, 0x83, 0x01}},
	{0x00, 1, 0x80},
	{0xff, 2 , {0x12, 0x83}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}	
};
#endif

static struct LCM_setting_table hx8394a_init_setting[] = {
#if 1	
	{0xB9,	3,	{0xFF,0x83,0x94}},
	{0xBA,	1,	{0x11}},//,0x82,0x00,0x16,0xC5,0x00,0x10,0xFF,0x0F,0x24,0x03,0x21,0x24,0x25,0x20,0x08}},   //set mipi 4 lane
	{0xB1,	16,	{0x01,0x00,0x54,0x87,0x01,0x11,0x11,0x35,0x3d,0x29,0x29,0x47,0x12,0x01,0xE6,0xE2}},
	{0xB4,	22, {0x80,0x08,0x32,0x10,0x06,0x32,0x15,0x08,0x32,0x10,0x08,0x33,0x05,0x44,0x0a,0x37,0x05,0x44,0x0A,0x68,0x68,0x0a}},//,0x06,0x44,0x06,0x5F,0x0A,0x6B,0x70,0x05,0x08}},
	{0xD5, 	54,	{0x00,0x00,0x0f,0x00,0x0A,0x00,0x01,0x00,0x00,0x00,0x33,0x00,0x45,0x67,0x01,0x23,0x01,0x23,0x88,0x88,0x88,0x99,0x88,0xaa,0xbb,0x99,0x99,0x99,0x88,0x88,0x88,0x88,0x32,0x10,0x76,0x54,0x32,0x10,0x88,0x88,0x88,0x88,0x99,0xbb,0xaa,0x99,0x99,0x99,0x88,0x88,0x88,0x88,0x1e,0x08}},
	{0xB6, 	1,	{0x16}},
	{0xE0, 	42,	{0x00,0x08,0x0d,0x37,0x3f,0x3f,0x1d,0x3f,0x07,0x0D,0x0e,0x11,0x13,0x11,0x12,0x11,0x18,0x00,0x08,0x0d,0x37,0x3f,0x3f,0x1d,0x3f,0x07,0x0D,0x0e,0x11,0x13,0x11,0x12,0x11,0x18,0x0B,0x17,0x06,0x11,0x0B,0x17,0x06,0x11}},
	{0xBF,	4,	{0x06,0x00,0x10,0x04}},
	{0xc0,	4,	{0x0c,0x14}},
	{0xC7, 	4,	{0x00,0x10,0x00,0x10}},
	{0xB2, 	6,	{0x00,0xC8,0x0f,0x05,0x00,0x22}},
	{0xCC, 	1,	{0x01}},//0x09
	{0xBC, 	1,	{0x07}},
	{0xC6, 	2,	{0x08,0x40}},
	{0xd4, 	1,	{0x32}},
	{0x35,	1,	{0x00}},    // set TE on
	{0x11,	0,	{}},     //sleep out
	{REGFLAG_DELAY, 200, {}},
	{0x29,	0,	{}},
	{REGFLAG_DELAY, 150, {}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}
#else
	{0xB9,	3,	{0xFF,0x83,0x94}},
	{0xBA,	6,	{0x63,0x03,0x68,0x6b,0xb2,0xc0}},   //set mipi 4 lane
	{0xB1,	10,	{0x50,0x0F,0x6F,0x09,0x33,0x33,0x71,0x31,0x50,0x30}},
	{0xB2, 	6,	{0x65,0x80,0x64,0x0e,0x0d,0x2f}},
	{0xB4,	21, {0x33,0x7d,0x33,0x7d,0x33,0x7d,0x05,0x0D,0x8E,0x55,0x00,0x3f,0x33,0x7d,0x33,0x7d,0x33,0x7d,0x05,0x0d,0x8e}},
	{0xE0, 	62,	{0x00,0x00,0x06,0x37,0x3f,0x3f,0x1d,0x3f,0x07,0x0D,0x0e,0x11,0x13,0x11,0x12,0x11,0x18,0x00,0x08,0x0d,
				 0x37,0x3f,0x3f,0x1d,0x3f,0x07,0x0D,0x0e,0x11,0x13,0x11,0x12,0x11,0x18,0x0B,0x17,0x06,0x11,0x0B,0x17,
				 0x06,0x11}},
	
	
	{0xBF,	2,	{0x06, 0x02}},
	{0xB6, 	1,	{0xF7}},
	{0xD5, 	32,	{0x00,0x00,0x00,0x00,0x0A,0x00,0x01,0x66,0x00,0x00,0x66,0x11,0x10,0x10,0x32,0x54,0x76,0xA9,0xCB,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x54,0x88,0x88}},
	{0xCC, 	1,	{0x01}},//0x09			
	{0xC6, 	1,	{0x08}},
	{0xBC, 	1,	{0x07}},
	{0xC7, 	4,	{0x00,0x10,0x00,0x10}},
	{0xE0, 	42,	{0x19,0x2A,0x2E,0x2E,0x34,0x39,0x32,0x43,0x07,0x0D,0x0F,0x12,0x13,0x12,0x13,0x0F,0x17,0x09,0x19,0x1C,0x2E,0x34,0x39,0x23,0x3D,0x06,0x0D,0x0E,0x11,0x13,0x11,0x13,0x11,0x18,0x0B,0x18,0x05,0x11,0x0B,0x17,0x07,0x12}},
	{0x35,	1,	{0x00}},    // set TE on
	{REGFLAG_DELAY, 10, {}},
	{0x11,	0,	{}},     //sleep out
	{REGFLAG_DELAY, 200, {}},
	{0x29,	0,	{}},
	{REGFLAG_DELAY, 150, {}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}
#endif
};

//static struct LCM_setting_table hx8394_test_config_para[] = {
//	{0xB9, 3, {0xFF, 0x83, 0x94}},
//	{REGFLAG_END_OF_TABLE, 0x00, {}}	
//};

static struct LCM_setting_table hx8394f_init_setting[] = {
#if 0	
	{0XB9,	3,	{0xFF,0x83,0x89}},
	{0XB1, 	20,	{0x7F,0x12,0x12,0x35,0x55,0x50,0xD0,0xF6,0x58,0x80,0x20,0x20,0xF8,0xAA,0xAA,0xA3,0x00,0x80,0x30,0x00}},
	{0XB2,	10,	{0x80,0x50,0x0C,0x12,0xF0,0x38,0x11,0x64,0x5D,0x09}},
	{0XB4, 	10,	{0x10,0x6C,0x10,0x6c,0x00,0x00,0x08,0x78,0x10,0x78}},
	{0XD3,	35,	{0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x32,0x10,0x07,0x00,0x07,0x03,0xCB,0x03,0xCB,0x00,0x00,0x00,0x00,0x37,0x04,0x09,0x09,0x37,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x0A,0x00,0x01}},
	{0XD5,  38,	{0x18,0x20,0x18,0x22,0x21,0x18,0x23,0x18,0x18,0x02,0x18,0x06,0x03,0x18,0x07,0x18,0x18,0x04,0x18,0x00,
			   0x05,0x18,0x01,0x18,0x27,0x18,0x25,0x18,0x18,0x26,0x18,0x24,0x18,0x00,0x18,0x18,0x18,0x18}},
	{0XD6, 38,	{0x18,0x27,0x18,0x25,0x26,0x18,0x24,0x18,0x18,0x01,0x18,0x05,0x00,0x18,0x04,0x18,0x18,0x07,0x18,0x03,
			   0x06,0x18,0x02,0x18,0x20,0x18,0x22,0x18,0x18,0x21,0x18,0x23,0x18,0x18,0x18,0x18,0x18,0x18}},
	{0XB6, 4,	{0x23,0x23,0x00,0x00}},
	{0XE0, 42,	{0x04,0x08,0x12,0x24,0x3d,0x3F,0x1a,0x39,0x06,0x08,0x09,0x16,0x0e,0x11,0x12,0x11,0x13,0x0b,0x16,0x16,
			   0x12,0x04,0x08,0x12,0x24,0x3d,0x3F,0x1a,0x39,0x06,0x08,0x09,0x16,0x0e,0x11,0x12,0x11,0x13,0x0b,0x16,
			   0x16,0x12}},
	{0XCC, 	1,	{0x02}},
	{0XD2, 	1,	{0x55}},	 
	{0XE4, 	2,	{0x00,0x01}},
	{REGFLAG_DELAY, 10, {}},
	{0X11, 	0,	{}},
	{REGFLAG_DELAY, 100, {}},
	{0X29, 	0,	{}},
	{REGFLAG_DELAY, 20, {}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}
	
#else
	{0XB9,	3,	{0xFF,0x83,0x94}},
	{REGFLAG_DELAY, 10, {}},
	{0xBA,	6,	{0x63,0x03,0x68,0x6B,0xb2,0xC0}},//63=4lane,62=3lane
	{0XB1, 	10,	{0x50,0x0F,0x6F,0x09,0x33,0x33,0x71,0x31,0x50,0x30}},
	{0XB2,	6,	{0x65,0x80,0x64,0x0E,0x0D,0x2F}},
	{0XB4,	21,	{0x33,0x7D,0x33,0x7D,0x33,0x7D,0x05,0x0D,0x8E,0x55,0x00,0x3F,0x33,0x7D,0x33,0x7D,0x33,0x7D,0x05,0x0D,0x8E}},
	{REGFLAG_DELAY, 1, {}},
	{0XE0,	58,	{0x00,0x00,0x06,0x0B,0x0D,0x11,0x14,0x12,0x28,0x3A,0x4D,0x4E,0x59,0x6D,0x73,0x75,0x84,0x88,0x84,0x93,
				 0xA4,0x51,0x4F,0x52,0x56,0x58,0x5E,0x61,0x7F,0x00,0x00,0x06,0x0A,0x0D,0x10,0x13,0x12,0x28,0x3A,0x4D,
				 0x4E,0x59,0x6C,0x72,0x75,0x82,0x88,0x84,0x93,0xA4,0X51,0x4F,0x52,0x55,0x58,0x5D,0x61,0x7F}},
	{REGFLAG_DELAY, 1, {}},
	{0xD3, 	33,	{0x00,0x00,0x07,0x07,0x00,0x00,0x08,0x08,0x32,0x10,0x09,0x00,0x09,0x32,0x15,0x0D,0x05,0x0D,0x32,0x10,
				 0x08,0x00,0x00,0x37,0x33,0x0C,0X0C,0x27,0x02,0x02,0x27,0x0E,0x40}},
	{REGFLAG_DELAY, 1, {}},
	{0xD5, 	44,	{0x27,0x26,0x25,0x24,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
				 0x18,0x18,0x18,0x18,0x18,0x18,0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x21,0x20,0x23,0x22,
				 0x18,0x18,0x18,0x18}},
	{REGFLAG_DELAY, 1, {}},
	{0xD6, 	44,	{0x20,0x21,0x22,0x23,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
				 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x26,0x27,0x24,0x25,
				 0x18,0x18,0x18,0x18}},
	{REGFLAG_DELAY, 1, {}},
	{0xCC, 	1,	{0x0b}},
	{0xC0, 	2,	{0x1F,0x73}},
	{0xD4, 	1,	{0x02}},
	{0xBD, 	1,	{0x01}},
	{0xB1, 	1,	{0x60}},
	{0xBD, 	1,	{0x00}},
	{0xB6, 	2,	{0x2E,0x2E}},
	{0xBF, 	7,	{0x40,0x81,0x50,0x00,0x1A,0xFC,0x01}},
	{0X11, 	0,	{}},
	{REGFLAG_DELAY, 200, {}},
	{0X29, 	0,	{}},
	{REGFLAG_DELAY, 100, {}},
	{REGFLAG_END_OF_TABLE, 0x00, {}}
#endif
};

static void LCD_panel_init(u32 sel)
{
	__u32 i;
	pr_info("[huyanhu:]LCD_panel_init!\n");
	
//	__u32 rx_num;
//	__u8 rx_bf0=0,rx_bf1=0,rx_bf2=0;
	__u32 hx8394a_used=0;
	
/*	int ret;
	ret = misc_register(&lcd_backlight);
	if(ret) {		
		pr_err("%s lcd-backlight register driver as misc device error\n", __FUNCTION__);
	}
	sysfs_create_file(&lcd_backlight.this_device->kobj,&lcd_backlight_attr);
*/	


	panel_rst(1);	 //add by lyp@20140423
	sunxi_lcd_delay_ms(10);//add by lyp@20140423
	panel_rst(0);
	sunxi_lcd_delay_ms(50);
	panel_rst(1);
	sunxi_lcd_delay_ms(80);
	
	sunxi_lcd_pin_cfg(sel, 1);
	sunxi_lcd_delay_ms(20);
	
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_EXIT_SLEEP_MODE);
//	sunxi_lcd_delay_ms(120);

	
	sunxi_lcd_dsi_clk_enable(sel);
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_SET_DISPLAY_ON);
	sunxi_lcd_delay_ms(20);
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_SOFT_RESET);
//	sunxi_lcd_delay_ms(5);

	if (hx8394a_used) {
		for (i=0;;i++) {
			if(hx8394a_init_setting[i].cmd == 0x02)
				break;
			else if (hx8394a_init_setting[i].cmd == 0x01)
				sunxi_lcd_delay_ms(hx8394a_init_setting[i].count);
			else
				dsi_dcs_wr(0,hx8394a_init_setting[i].cmd,hx8394a_init_setting[i].para_list,hx8394a_init_setting[i].count);
				
		}
		printk("[huyanhu:]hx8394a_init_setting i = %d end!\n",i);
//	} else if(hx8394a_used == 0) //hx8394f used
	} else if(hx8394a_used == 0)
	{
		for (i=0;;i++) {
			if(hx8394f_init_setting[i].cmd == 0x02)
				break;
			else if (hx8394f_init_setting[i].cmd == 0x01)
				sunxi_lcd_delay_ms(hx8394f_init_setting[i].count);
			else
//RGB			
//				dsi_dcs_wr(0,hx8394f_init_setting[i].cmd,hx8394f_init_setting[i].para_list,hx8394f_init_setting[i].count);	
				sunxi_lcd_dsi_dcs_write(0,hx8394f_init_setting[i].cmd,hx8394f_init_setting[i].para_list,hx8394f_init_setting[i].count);
//MPU				
//				dsi_gen_wr(0,hx8394f_init_setting[i].cmd,hx8394f_init_setting[i].para_list,hx8394f_init_setting[i].count);	
//				sunxi_lcd_dsi_gen_write(0,hx8394f_init_setting[i].cmd,hx8394f_init_setting[i].para_list,hx8394f_init_setting[i].count);
		}
//		sunxi_lcd_delay_ms(10);
		pr_info("[huyanhu:]hx8394f_init_setting i = %d end!\n",i);
	}
	
//	sunxi_lcd_dsi_clk_enable(sel);
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_SET_DISPLAY_ON);
//	sunxi_lcd_delay_ms(20);

	pr_info("[huyanhu:]LCD_panel_init-------------------exit\n");
	return;
}

static void LCD_panel_exit(u32 sel)
{
	sunxi_lcd_dsi_clk_disable(sel);
	sunxi_lcd_delay_ms(20);
	panel_rst(0);
//	sunxi_lcd_delay_ms(5);
	
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_SET_DISPLAY_OFF);
//	sunxi_lcd_delay_ms(20);
//	sunxi_lcd_dsi_dcs_write_0para(sel,DSI_DCS_ENTER_SLEEP_MODE);
//	sunxi_lcd_delay_ms(80);

	return ;
}

//sel: 0:lcd0; 1:lcd1
static s32 LCD_user_defined_func(u32 sel, u32 para1, u32 para2, u32 para3)
{
	return 0;
}

//sel: 0:lcd0; 1:lcd1
static s32 LCD_set_bright(u32 sel, u32 bright)
{
	sunxi_lcd_dsi_dcs_write_1para(sel,0x51,bright);
	return 0;
}

__lcd_panel_t sl006p_panel = {
	/* panel driver name, must mach the name of lcd_drv_name in sys_config.fex */
	.name = "sl006p",
	.func = {
		.cfg_panel_info = LCD_cfg_panel_info,
		.cfg_open_flow = LCD_open_flow,
		.cfg_close_flow = LCD_close_flow,
		.lcd_user_defined_func = LCD_user_defined_func,
		.set_bright = LCD_set_bright,
	},
};
